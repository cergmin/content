---
title: "Введение в алгоритмы"
description: "Базовые понятия в алгоритмах и то, зачем их изучать"
authors:
  - cergmin
tags:
  - article
---

## Кратко
Алгоритм — это точно определённая последовательность действий, по которой испольнитель сможет прийти от входных данных к итоговому результату за конечное время.

### Свойства алгоритмов
В определении выше отражены некоторые свойства алгоритмов, давайте их обозначим и разберём.

#### Массовость
Массовость означает, что мы можем применить алгоритм к разным наборам входных данных.

Если у нас есть функция, которая делит одно число на другое, то мы можем передавать в неё разные пары значений.

```js
function divide(a, b) {
  if (b === 0) {
    // Ошибка — тоже результат.
    throw new Error('Нельзя делить на ноль!');
  }

  return a / b;
}

divide(6, 3); // 2
divide(1, 4); // 0.25
divide(5, 0); // Uncaught Error: Нельзя делить на ноль!
```

#### Дискретность
Дискретность означает, что алгоритм должен состоять из простых шагов, которые выполняются друг за другом.

Функция, которая ищет корни квадратного уравнения (`ax² + bx + c = 0`) — не волшебная коробка, в которыю мы суём три числа и чудесным образом получаем ответ, она вычисляет всё маленькими шагами:

1. Вычислить дискриминант (`D = b² - 4ac`)
    1. Возвести `b` в квадрат
    1. Умножить `4` на `a` и на `c`
    1. Найти разность предыдущих двух шагов
1. Вычислить первый корень
    1. Найти корень из дискриминанта
    1. Сложить с `-b`
    1. Разделить сумму на `2a`
1. Вычислить второй корень
    1. Найти корень из дискриминанта
    1. Вычесть из `-b`
    1. Разделить разность на `2a`

```js
function getSquareRoots(a, b, c) {
  const D = b ** 2 - 4 * a * c;

  const x1 = (-b + Math.sqrt(D)) / (2 * a);
  const x2 = (-b - Math.sqrt(D)) / (2 * a);

  return [x1, x2];
}

// x² - 5x + 6 = 0
getSquareRoots(1, -5, 6); // [3, 2]
```

#### Детерминированность (Определённость)
Определённость означает, что каждый шаг алгоритма должен быть однозначен и чётко поняетн исполнителю.

Если в рецепте блюда нас просят добавить немного соли или разбить 2-4 яйца, то это не определённый (детерминированный) алгоритм, потому что мы не можем чётко и однозначно сказать сколько нужно ингредиентов.

#### Конечность
Конечность означает, что алгоритм должен приводить к итоговому результату за конечное число шагов.

## Зачем изучать алгоритмы?
...

## Оценка эффективности
### Наивный способ
Как понять, насколько эффективно работает алгоритм? Можно посчитать время выполнения в секундах, но оно зависит от мощности устройства и объёма входных данных, следовательно такой вариант нам не очень подходит.

### Временная сложность
Другой способ измерить эффективность — посчитать количество элементарных операций, которое используется в алгоритме, так наша оценка не будет зависить от устройства, на котором выполняется код. Конечно, количество операций практически всегда зависит от объёма входных данных, но эту проблему легко решить, если использовать переменные, отражающие размеры принимаемых значений.

Например, у нас есть алгоритм, который пробегается по [массиву](/js/arrays) чисел и возвращает максимальное значение.

```js
function getMaxValue(array) {
  const n = array.length();
  let maxValue = array[0];

  for (let i = 1; i < n; i++) {
    if (array[i] > maxValue) {
      maxValue = array[i];
    }
  }

  return maxValue;
}
```

Массив может содержать разное количество элементов, следовательно количество операций тоже может быть разынм. Для оценки эффективности этого алгоритма следует ввести переменную, например `n`, которая будет характеризовать размер массива, тогда мы сможем сказать, что в худшем случае алгоритм выполняет `4n + 3` действия _(2n + 3 присвоения и 2n сравнения)_.

Сейчас можно заметить три проблемы:
1. Точное количество действий зависит от того, как мы определяем элементарную операцию.
1. При росте входных данных, влияние слагаемых и множителей низших порядков становится крайне незначительным.
1. Если количество операций двух алгоритмов описывается большими формулами, например `629n³ + 29n² + 16n + 76` и `n⁴ + 17n + 931`, то нам становится очень непросто определить, какой их них эффективнее.

Таким образом, мы подходим к понятию «aсимптотической сложности».

### Асимптотическая сложность

Важно отметить, что мы говорим именно о худшем случае, потому что алгоритм может выполнять разное количество шагов в зависимости от набора входных данных.

...можно оценивать не только время, но и память.

## Структуры данных ??? или типы ???

### Абстрактный тип данных

## Итерация и рекурсия
